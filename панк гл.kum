использовать Рисователь

| ************************************
| Глобальные переменные
| местный /dev/null
лог поебать
| сюда пишется состояние холста при вызове "дамп холста" 
литтаб буфер_вида[0:ширина листа, 0:высота листа]
| здесь тусит переменная, отвечающаяя за самый яркий цвет на холсте
вещ бк
бк := 255

| ************************************
| Параметры отрисовки
вещ размер_вьюпорта; размер_вьюпорта := 1
вещ расст_до_вьюпорта; расст_до_вьюпорта := 1
лит вектор3_позиция_камеры
вектор3_позиция_камеры := новый вектор3(0, 0, 0)
лит РГБ_цвет_фона
РГБ_цвет_фона := новый РГБ(255, 255, 255)
литтаб сферы[0:2]
цел колво_сфер; колво_сфер := 3
сферы[0] := новая сфера(новый вектор3(0, -1, 3), 1, красный)
сферы[1] := новая сфера(новый вектор3(2, 0, 4), 1, синий)
сферы[2] := новая сфера(новый вектор3(-2, 0, 4), 1, зеленый)

алг
нач
новый лист (50, 50, черный)
рендер сцены
кон

| СТРУКТУРЫ В КУМИРЕ   
| ------------------
| Бесславный язык не позволяет оформлять классы или структуры
| Поэтому сериализуем и десериализуем их из строк
| Эту задачу выполняют функции ниже
| Работают эти структуры как в плюсах.
| ------------------
| Значение свойства "null" зарезервировано и обозначает,
| не верится, null.
| Все свойства начинаются с "$", для избежания пересечений
| названии свойств с их значениями.  
| Данные объекта хранятся в виде "$св1:зн1;$св2:зн2;"
алг присвоить_свойство(аргрез лит получатель, арг лит свойство, арг лит значение)
нач
| Стираем свойство, если оно уже присутствует в объекте 
удалить_свойство(получатель, свойство)
лит сериал_св 
сериал_св := "$" + свойство + ":" + значение + ";"
получатель := получатель + сериал_св
кон

алг лит получить_свойство(арг лит источник, арг лит свойство)
нач
цел нач_св, кон_св
лит стр_св
стр_св := _представление_свойства(свойство)
нач_св := позиция(источник, стр_св, 1)
если нач_св = 0 то знач := "null"
иначе
| кон_св := позиция(источник, ";", нач_св)
кон_св := найти конец(источник, "$", ";", нач_св)
знач := источник[нач_св + длин(стр_св) : кон_св - 1]
все
кон

алг удалить_свойство(аргрез лит получатель, арг лит свойство)
нач
цел нач_св, кон_св
лит стр_св, темп
если не получить_свойство(получатель, свойство) = "null"
то
стр_св := _представление_свойства(свойство)
нач_св := позиция(получатель, стр_св, 1)
кон_св := позиция(получатель, ";", нач_св)
темп := получатель[1:нач_св - 1] + получатель[кон_св + 1:длин(получатель)] 
получатель := темп
все
кон

алг лит _представление_свойства(арг лит свойство)
нач знач := "$" + свойство + ":" кон

| ***********************************************
| Конструкторы основных структур данных программы    
| ***********************************************

| Двухмерный вектор
алг лит новый вектор2(арг вещ x, арг вещ y)
нач
лит в2
в2 := ""
присвоить_свойство(в2, "x", вещ_в_лит(x))
присвоить_свойство(в2, "y", вещ_в_лит(y))
знач := в2
кон

| Трехмерный вектор
алг лит новый вектор3(арг вещ x, арг вещ y, арг вещ z)
нач
лит в3
в3 := новый вектор2(x, y)
присвоить_свойство(в3, "z", вещ_в_лит(z))
знач := в3
кон

алг вещ скалярное произведение(арг лит вектор3_1, арг лит вектор3_2)
нач
вещ прод_x, прод_y, прод_z
прод_x := лит_в_вещ(получить_свойство(вектор3_1, "x"), поебать) * лит_в_вещ(получить_свойство(вектор3_2, "x"), поебать)
прод_y := лит_в_вещ(получить_свойство(вектор3_1, "y"), поебать) * лит_в_вещ(получить_свойство(вектор3_2, "y"), поебать)
прод_z := лит_в_вещ(получить_свойство(вектор3_1, "z"), поебать) * лит_в_вещ(получить_свойство(вектор3_2, "z"), поебать)
знач := прод_x + прод_y + прод_z
кон

алг лит вектор3 разность(арг лит вектор3_1, арг лит вектор3_2)
нач
вещ разн_x, разн_y, разн_z
разн_x := лит_в_вещ(получить_свойство(вектор3_1, "x"), поебать) - лит_в_вещ(получить_свойство(вектор3_2, "x"), поебать)
разн_y := лит_в_вещ(получить_свойство(вектор3_1, "y"), поебать) - лит_в_вещ(получить_свойство(вектор3_2, "y"), поебать)
разн_z := лит_в_вещ(получить_свойство(вектор3_1, "z"), поебать) - лит_в_вещ(получить_свойство(вектор3_2, "z"), поебать)
знач := новый вектор3(разн_x, разн_y, разн_z)
кон

| Конец
алг лит новый РГБ(арг вещ р1, арг вещ г1, арг вещ б1)
нач
лит РГБ
РГБ:= ""
присвоить_свойство(РГБ, "R", цел_в_лит(realtoint(р1)))
присвоить_свойство(РГБ, "G", цел_в_лит(realtoint(г1)))
присвоить_свойство(РГБ, "B", цел_в_лит(realtoint(б1)))
знач := РГБ
кон

алг лит новый РГБА(арг вещ р1, арг вещ г1, арг вещ б1, арг вещ а)
нач
лит РГБА
РГБА := новый РГБ(р1, г1, б1)
присвоить_свойство(РГБА, "A", цел_в_лит(realtoint(а)))
знач := РГБА
кон

алг лит новая сфера(арг лит вектор3_центр, арг вещ радиус, арг цвет колор)
нач
лит сфера
сфера := ""
присвоить_свойство(сфера, "вектор3_центр", вектор3_центр)
присвоить_свойство(сфера, "радиус", вещ_в_лит(радиус))
присвоить_свойство(сфера, "цвет", цвет_в_лит(колор))
знач := сфера 
кон

| Сериализация и десериализация цветов
алг лит цвет_в_лит(цвет ц)
нач
цел р, г, б
разложить в RGB (ц, р, г, б)
знач := новый РГБ(р,г,б)
кон 

алг цвет лит_в_цвет(лит РГБ)
нач
цел р, г, б
р := realtoint(лит_в_вещ(получить_свойство(РГБ, "R"), поебать))
г := realtoint(лит_в_вещ(получить_свойство(РГБ, "G"), поебать))
б := realtoint(лит_в_вещ(получить_свойство(РГБ, "B"), поебать))
знач := RGB(р, г, б)
кон

| Линейное сжатие HDR до RGB
алг лит hdr_to_rgb(арг лит raw)
нач
| пуллим цвета и находим максимальное отклонение
вещ р, г, б, к
р:=лит_в_вещ(получить_свойство(raw,"R"),поебать)
г:=лит_в_вещ(получить_свойство(raw,"G"),поебать)
б:=лит_в_вещ(получить_свойство(raw,"B"),поебать)
|ищем коэффициент
если бк>255 то
к:=255/бк
|умножаем все цвета на этот коэффициент
р:=р*к
г:=г*к
б:=б*к
иначе
все
|пишем новый цвет в класс
знач:=новый РГБ(р,г,б)
кон


алг цел вырвать целое(аргрез лит строка)
нач
цел поз_разд
лог одно_число
| проверяем не осталось ли одинокое число
если длин(строка) <= 3 
то знач := лит_в_цел(строка, одно_число)
иначе одно_число := нет
все
если одно_число
то
| вычищаем вилкой строчку, хоть это и не необходимо
строка := ""
иначе 
| функция поз из стдлиб не работает блядь
поз_разд := позиция(строка, ";", 1)
знач := лит_в_цел(строка[1:поз_разд-1], поебать)
строка := строка[поз_разд+1:длин(строка)]
все
кон

| Возвращает позицию начала подстроки в строке 
алг цел позиция(арг лит строка, арг лит разделитель, арг цел нач_поз)
нач
цел поз
если длин(разделитель) > длин(строка) то знач := 0
иначе
поз := нач_поз
нц пока не (строка[поз:поз+длин(разделитель) - 1] = разделитель) и (поз + длин(разделитель) <= длин(строка))
поз := поз + 1
кц
| если разделитель не найден, даем 0
если строка[поз:поз+длин(разделитель) - 1] = разделитель
то
знач := поз
иначе
знач := 0
все
все
кон

алг цел найти конец(арг лит строка, арг лит вниз, арг лит вверх, арг цел нач_поз)
нач
цел поз
цел глубина
сим символЪ
глубина := 0
нц для поз от (нач_поз + 1) до длин(строка)
символЪ := строка[поз]
выбор 
при строка[поз] = вниз : глубина := глубина + 1
при строка[поз] = вверх : глубина := глубина - 1
все
если (глубина < 0) то
знач := поз
выход 
все
кц
кон

| округление вещ с переводом в цел
алг цел realtoint(арг вещ в)
нач
лит л
цел ц 
если в - int(в) >= 0.5
то л := вещ_в_лит(int(в) + 1)
иначе л := вещ_в_лит(int(в))
все
л := л[1:длин(л) - 2]  
ц := лит_в_цел(л,поебать)
знач := ц 
кон

| работа с текстурами
алг загрузить текстуру(арг лит путь)
нач

кон

| для сохранения читаемости и понятности дублирую код
алг загрузить холст
нач
цел х, у
нц для х от 0 до ширина листа - 1
нц для у от 0 до высота листа - 1
пиксель (х, у, лит_в_цвет(буфер_вида[х,у]))
кц
вывод "Загрузка: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Загружено!", нс
кон

алг сохранить холст
нач
цел х, у
нц для х от 0 до ширина листа - 1 
нц для у от 0 до высота листа - 1
буфер_вида[х, у] := цвет_в_лит(значение в точке(х, у))
кц
вывод "Сохранение: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Сохранено!", нс
кон

алг деформировать пикчу
нач
цел х, у, р, г, б
цвет темп
нц для х от 0 до ширина листа - 1 
нц для у от 0 до высота листа - 1
если rnd(100) >= 95 то
темп := лит_в_цвет(буфер_вида[х, у])
разложить в RGB (темп, р, г, б)
буфер_вида[х, у] := цвет_в_лит(RGB(255 - р, 255 - г, 255 - б))
если р + г + б > 512
то буфер_вида[х, у] := цвет_в_лит(RGB(р+int((255-р)*0.7), г+int((255-г)*0.7), б+int((255-б)*0.7)))
все
все 
кц
вывод "Деформация: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Разъебано!", нс
кон

| ************************************
| КОД ТРЕЙСЕРА                              
| ************************************
алг лит вектор3 холст_в_вьюпорт(арг лит вектор2_п2д)
нач
вещ x, y, z
x := лит_в_вещ(получить_свойство(вектор2_п2д, "x"), поебать) * размер_вьюпорта / ширина листа
y := лит_в_вещ(получить_свойство(вектор2_п2д, "y"), поебать) * размер_вьюпорта / высота листа
z := расст_до_вьюпорта
знач := новый вектор3(x, y, z)
кон

алг лит пересечение_луч_сфера(арг лит вектор3_начало_координат, арг лит вектор3_направление_луча, арг лит сфера)
нач
лит вектор3_ос
вещ к1, к2, к3
вектор3_ос := вектор3 разность(вектор3_начало_координат, получить_свойство(сфера, "вектор3_центр"))
к1 := скалярное произведение(вектор3_направление_луча, вектор3_направление_луча)
к2 := 2 * скалярное произведение(вектор3_ос, вектор3_направление_луча)
к3 := скалярное произведение(вектор3_ос, вектор3_ос) - лит_в_вещ(получить_свойство(сфера, "радиус"), поебать)*лит_в_вещ(получить_свойство(сфера, "радиус"), поебать) 

вещ дискриминант
дискриминант := к2*к2 - 4*к1*к3

если дискриминант < 0 
то знач := новый вектор2(0, 0) 
иначе знач := новый вектор2((-1 * к2 + sqrt(дискриминант)) / (2*к1) ,(-к2 - sqrt(дискриминант)) / (2*к1)) все 

кон

алг цвет трассировка луча(арг лит вектор3_начало_координат, арг лит вектор3_направление, арг вещ мин_т, арг вещ макс_т)
нач
вещ ближ_т
лит сфера_ближ_сф
ближ_т := МАКСВЕЩ; сфера_ближ_сф := "null"

цел итер
лит вектор2_тс
вещ тс_x, тс_y
нц для итер от 0 до колво_сфер - 1
вектор2_тс := пересечение_луч_сфера(вектор3_начало_координат, вектор3_направление, сферы[итер])
тс_x := лит_в_вещ(получить_свойство(вектор2_тс, "x"), поебать)
тс_y := лит_в_вещ(получить_свойство(вектор2_тс, "y"), поебать)
если (тс_x < ближ_т и мин_т < тс_x и тс_x < макс_т) то
ближ_т := тс_x
сфера_ближ_сф := сферы[итер]
все

если (тс_y < ближ_т и мин_т < тс_y и тс_y < макс_т) то
ближ_т := тс_y
сфера_ближ_сф := сферы[итер]
все
кц

если сфера_ближ_сф = "null" 
то 
знач := лит_в_цвет(РГБ_цвет_фона)
иначе
знач := лит_в_цвет(получить_свойство(сфера_ближ_сф, "цвет"))
все
кон

алг закрасить пиксель(арг цел x, арг цел y, арг цвет колор)
нач
цел реал_x, реал_y
реал_x := int(ширина листа / 2) + x
реал_y := int(высота листа / 2) - y - 1

если (реал_x < 0 или реал_x >= ширина листа или реал_y < 0 или реал_y >= высота листа)
то выход
все
пиксель (реал_x, реал_y, колор)
кон

алг рендер сцены
нач
цел x, y
лит вектор3_направление
цвет цвет_точки
нц для x от int(-ширина листа / 2) до int(ширина листа / 2) 
нц для y от int(-высота листа / 2) до int(высота листа / 2) 
вектор3_направление := вектор3 холст_в_вьюпорт(новый вектор2(x, y))
цвет_точки := трассировка луча(вектор3_позиция_камеры, вектор3_направление, 1, МАКСВЕЩ)
закрасить пиксель (x, y, цвет_точки)
кц
кц 
кон

| оффтопик дерьмо
алг веб один ноль
нач
цел видтх
нц для видтх от 0 до ширина листа
перо (1, RGB(0, 0, int (255 * видтх / ширина листа)))
линия (видтх, 0, видтх, высота листа)
кц
кон


