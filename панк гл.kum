использовать Рисователь

| местный /dev/null
лог поебать
| сюда пишется состояние холста при вызове "дамп холста" 
литтаб буфер_вида[0:ширина листа, 0:высота листа]
| здесь тусит переменная, отвечающаяя за самый яркий цвет на холсте
вещ бк
бк := 255

алг
нач
лит вектор3_О
вектор3_О := новый вектор3(1, 2, 1)
присвоить_свойство(вектор3_О, "y", "5")
присвоить_свойство(вектор3_О, "x", "7")
вывод вектор3_О

лит РГБ1_1
РГБ1_1 := новый РГБ(50,40,40)
вывод РГБ1_1

лит свво
свво:= получить_свойство(РГБ1_1,"R")
вывод свво 

вывод hdr_to_rgb(РГБ1_1)
кисть(лит_в_цвет(РГБ1_1))
кон

| СТРУКТУРЫ В КУМИРЕ   
| ------------------
| Бесславный язык не позволяет оформлять классы или структуры
| Поэтому сериализуем и десериализуем их из строк
| Эту задачу выполняют функции ниже
| Работают эти структуры как в плюсах.
| ------------------
| Значение свойства "null" зарезервировано и обозначает,
| не верится, null.
| Все свойства начинаются с "$", для избежания пересечений
| названии свойств с их значениями.  
| Данные объекта хранятся в виде "$св1:зн1;$св2:зн2;"
алг присвоить_свойство(аргрез лит получатель, арг лит свойство, арг лит значение)
нач
| Стираем свойство, если оно уже присутствует в объекте 
удалить_свойство(получатель, свойство)
лит сериал_св 
сериал_св := "$" + свойство + ":" + значение + ";"
получатель := получатель + сериал_св
кон

алг лит получить_свойство(арг лит источник, арг лит свойство)
нач
цел нач_св, кон_св
лит стр_св
стр_св := _представление_свойства(свойство)
нач_св := позиция(источник, стр_св, 1)
если нач_св = 0 то знач := "null"
иначе
кон_св := позиция(источник, ";", нач_св)
знач := источник[нач_св + длин(стр_св) : кон_св - 1]
все
кон

алг удалить_свойство(аргрез лит получатель, арг лит свойство)
нач
цел нач_св, кон_св
лит стр_св, темп
если не получить_свойство(получатель, свойство) = "null"
то
стр_св := _представление_свойства(свойство)
нач_св := позиция(получатель, стр_св, 1)
кон_св := позиция(получатель, ";", нач_св)
темп := получатель[1:нач_св - 1] + получатель[кон_св + 1:длин(получатель)] 
получатель := темп
все
кон

алг лит _представление_свойства(арг лит свойство)
нач знач := "$" + свойство + ":" кон

| ***********************************************
| Конструкторы основных структур данных программы    
| ***********************************************
алг лит новый вектор3(арг цел x, арг цел y, арг цел z)
нач
лит в3
в3 := ""
присвоить_свойство(в3, "x", цел_в_лит(x))
присвоить_свойство(в3, "y", цел_в_лит(y))
присвоить_свойство(в3, "z", цел_в_лит(z))
знач := в3
кон

алг лит новый РГБ (арг вещ р1, арг вещ г1, арг вещ б1)
нач
лит РГБ
РГБ:= ""
присвоить_свойство(РГБ, "R", цел_в_лит(realtoint(р1)))
присвоить_свойство(РГБ, "G", цел_в_лит(realtoint(г1)))
присвоить_свойство(РГБ, "B", цел_в_лит(realtoint(б1)))
знач := РГБ
кон

алг лит новый РГБА (арг вещ р1, арг вещ г1, арг вещ б1, арг вещ а)
нач
лит РГБА
РГБА := новый РГБ(р1, г1, б1)
присвоить_свойство(РГБА, "A", цел_в_лит(realtoint(а)))
знач := РГБА
кон

| Сериализация и десериализация цветов
алг лит цвет_в_лит(цвет ц)
нач
цел р, г, б
разложить в RGB (ц, р, г, б)
знач := новый РГБ(р,г,б)
кон 

алг цвет лит_в_цвет(лит РГБ)
нач
цел р, г, б
р := realtoint(лит_в_вещ(получить_свойство(РГБ, "R"), поебать))
г := realtoint(лит_в_вещ(получить_свойство(РГБ, "G"), поебать))
б := realtoint(лит_в_вещ(получить_свойство(РГБ, "B"), поебать))
знач := RGB(р, г, б)
кон

| Линейное сжатие HDR до RGB
алг лит hdr_to_rgb(арг лит raw)
нач
| пуллим цвета и находим максимальное отклонение
вещ р, г, б, к
р:=лит_в_вещ(получить_свойство(raw,"R"),поебать)
г:=лит_в_вещ(получить_свойство(raw,"G"),поебать)
б:=лит_в_вещ(получить_свойство(raw,"B"),поебать)
|ищем коэффициент
если бк>255 то
к:=255/бк
|умножаем все цвета на этот коэффициент
р:=р*к
г:=г*к
б:=б*к
иначе
все
|пишем новый цвет в класс
знач:=новый РГБ(р,г,б)
кон


алг цел вырвать целое(аргрез лит строка)
нач
цел поз_разд
лог одно_число
| проверяем не осталось ли одинокое число
если длин(строка) <= 3 
то знач := лит_в_цел(строка, одно_число)
иначе одно_число := нет
все
если одно_число
то
| вычищаем вилкой строчку, хоть это и не необходимо
строка := ""
иначе 
| функция поз из стдлиб не работает блядь
поз_разд := позиция(строка, ";", 1)
знач := лит_в_цел(строка[1:поз_разд-1], поебать)
строка := строка[поз_разд+1:длин(строка)]
все
кон

| Возвращает позицию начала подстроки в строке 
алг цел позиция(арг лит строка, арг лит разделитель, арг цел нач_поз)
нач
цел поз
если длин(разделитель) > длин(строка) то знач := 0
иначе
поз := нач_поз
нц пока не (строка[поз:поз+длин(разделитель) - 1] = разделитель) и (поз + длин(разделитель) <= длин(строка))
поз := поз + 1
кц
| если разделитель не найден, даем 0
если строка[поз:поз+длин(разделитель) - 1] = разделитель
то
знач := поз
иначе
знач := 0
все
все
кон

| округление вещ с переводом в цел
алг цел realtoint(арг вещ в)
нач
лит л
цел ц 
если в - int(в) >= 0.5
то л := вещ_в_лит(int(в) + 1)
иначе л := вещ_в_лит(int(в))
все
л := л[1:длин(л) - 2]  
ц := лит_в_цел(л,поебать)
знач := ц 
кон

| работа с текстурами
алг загрузить текстуру(арг лит путь)
нач

кон

| для сохранения читаемости и понятности дублирую код
алг загрузить холст
нач
цел х, у
нц для х от 0 до ширина листа - 1
нц для у от 0 до высота листа - 1
пиксель (х, у, лит_в_цвет(буфер_вида[х,у]))
кц
вывод "Загрузка: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Загружено!", нс
кон

алг сохранить холст
нач
цел х, у
нц для х от 0 до ширина листа - 1 
нц для у от 0 до высота листа - 1
буфер_вида[х, у] := цвет_в_лит(значение в точке(х, у))
кц
вывод "Сохранение: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Сохранено!", нс
кон

алг деформировать пикчу
нач
цел х, у, р, г, б
цвет темп
нц для х от 0 до ширина листа - 1 
нц для у от 0 до высота листа - 1
если rnd(100) >= 95 то
темп := лит_в_цвет(буфер_вида[х, у])
разложить в RGB (темп, р, г, б)
буфер_вида[х, у] := цвет_в_лит(RGB(255 - р, 255 - г, 255 - б))
если р + г + б > 512
то буфер_вида[х, у] := цвет_в_лит(RGB(р+int((255-р)*0.7), г+int((255-г)*0.7), б+int((255-б)*0.7)))
все
все 
кц
вывод "Деформация: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Разъебано!", нс
кон

| код трейсера
алг рендер сцены
нач

кон

| оффтопик дерьмо
алг веб один ноль
нач
цел видтх
нц для видтх от 0 до ширина листа
перо (1, RGB(0, 0, int (255 * видтх / ширина листа)))
линия (видтх, 0, видтх, высота листа)
кц
кон

