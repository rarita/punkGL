использовать Рисователь

| местный /dev/null
лог поебать
| сюда пишется состояние холста при вызове "дамп холста" 
литтаб буфер_вида[0:ширина листа, 0:высота листа]

алг
нач
лит вектор3_О
вектор3_О := новый вектор3(1, 2, 1)
присвоить_свойство(вектор3_О, "y", "5")
присвоить_свойство(вектор3_О, "x", "7")
вывод вектор3_О
кон

| СТРУКТУРЫ В КУМИРЕ   
| ------------------
| Бесславный язык не позволяет оформлять классы или структуры
| Поэтому сериализуем и десериализуем их из строк
| Эту задачу выполняют функции ниже
| Работают эти структуры как в плюсах.
| ------------------
| Значение свойства "null" зарезервировано и обозначает,
| не верится, null.
| Все свойства начинаются с "$", для избежания пересечений
| названии свойств с их значениями.  
| Данные объекта хранятся в виде "$св1:зн1;$св2:зн2;"
алг присвоить_свойство(аргрез лит получатель, арг лит свойство, арг лит значение)
нач
| Стираем свойство, если оно уже присутствует в объекте 
удалить_свойство(получатель, свойство)
лит сериал_св 
сериал_св := "$" + свойство + ":" + значение + ";"
получатель := получатель + сериал_св
кон

алг лит получить_свойство(арг лит источник, арг лит свойство)
нач
цел нач_св, кон_св
лит стр_св
стр_св := _представление_свойства(свойство)
нач_св := позиция(источник, стр_св, 1)
если нач_св = 0 то знач := "null"
иначе
кон_св := позиция(источник, ";", нач_св)
знач := источник[нач_св + длин(стр_св) : кон_св - 1]
все
кон

алг удалить_свойство(аргрез лит получатель, арг лит свойство)
нач
цел нач_св, кон_св
лит стр_св, темп
если не получить_свойство(получатель, свойство) = "null"
то
стр_св := _представление_свойства(свойство)
нач_св := позиция(получатель, стр_св, 1)
кон_св := позиция(получатель, ";", нач_св)
темп := получатель[1:нач_св - 1] + получатель[кон_св + 1:длин(получатель)] 
получатель := темп
все
кон

алг лит _представление_свойства(арг лит свойство)
нач знач := "$" + свойство + ":" кон

| ***********************************************
| Конструкторы основных структур данных программы    
| ***********************************************
алг лит новый вектор3(арг цел x, арг цел y, арг цел z)
нач
лит в3
в3 := ""
присвоить_свойство(в3, "x", цел_в_лит(x))
присвоить_свойство(в3, "y", цел_в_лит(y))
присвоить_свойство(в3, "z", цел_в_лит(z))
знач := в3
кон

| Сериализация и десериализация цветов
алг лит цвет_в_лит(цвет ц)
нач
цел р, г, б
разложить в RGB (ц, р, г, б)
знач := цел_в_лит(р) + ";" + цел_в_лит(г) + ";" + цел_в_лит(б)
кон 

алг цвет лит_в_цвет(лит л)
нач
лит темп
темп := л
цел р, г, б
р := вырвать целое (темп)
г := вырвать целое (темп)
б := вырвать целое (темп)
знач := RGB(р, г, б)
кон

алг цел вырвать целое(аргрез лит строка)
нач
цел поз_разд
лог одно_число
| проверяем не осталось ли одинокое число
если длин(строка) <= 3 
то знач := лит_в_цел(строка, одно_число)
иначе одно_число := нет
все
если одно_число
то
| вычищаем вилкой строчку, хоть это и не необходимо
строка := ""
иначе 
| функция поз из стдлиб не работает блядь
поз_разд := позиция(строка, ";", 1)
знач := лит_в_цел(строка[1:поз_разд-1], поебать)
строка := строка[поз_разд+1:длин(строка)]
все
кон

| Возвращает позицию начала подстроки в строке 
алг цел позиция(арг лит строка, арг лит разделитель, арг цел нач_поз)
нач
цел поз
если длин(разделитель) > длин(строка) то знач := 0
иначе
поз := нач_поз
нц пока не (строка[поз:поз+длин(разделитель) - 1] = разделитель) и (поз + длин(разделитель) <= длин(строка))
поз := поз + 1
кц
| если разделитель не найден, даем 0
если строка[поз:поз+длин(разделитель) - 1] = разделитель
то
знач := поз
иначе
знач := 0
все
все
кон

| работа с текстурами
алг загрузить текстуру(арг лит путь)
нач

кон

| для сохранения читаемости и понятности дублирую код
алг загрузить холст
нач
цел х, у
нц для х от 0 до ширина листа - 1
нц для у от 0 до высота листа - 1
пиксель (х, у, лит_в_цвет(буфер_вида[х,у]))
кц
вывод "Загрузка: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Загружено!", нс
кон

алг сохранить холст
нач
цел х, у
нц для х от 0 до ширина листа - 1 
нц для у от 0 до высота листа - 1
буфер_вида[х, у] := цвет_в_лит(значение в точке(х, у))
кц
вывод "Сохранение: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Сохранено!", нс
кон

алг деформировать пикчу
нач
цел х, у, р, г, б
цвет темп
нц для х от 0 до ширина листа - 1 
нц для у от 0 до высота листа - 1
если rnd(100) >= 95 то
темп := лит_в_цвет(буфер_вида[х, у])
разложить в RGB (темп, р, г, б)
буфер_вида[х, у] := цвет_в_лит(RGB(255 - р, 255 - г, 255 - б))
если р + г + б > 512
то буфер_вида[х, у] := цвет_в_лит(RGB(р+int((255-р)*0.7), г+int((255-г)*0.7), б+int((255-б)*0.7)))
все
все 
кц
вывод "Деформация: выполнено " + вещ_в_лит(((х*у)/((ширина листа - 1)*(высота листа - 1))*100)) + "%", нс
кц
вывод "Разъебано!", нс
кон

| код трейсера
алг рендер сцены
нач

кон

| оффтопик дерьмо
алг веб один ноль
нач
цел видтх
нц для видтх от 0 до ширина листа
перо (1, RGB(0, 0, int (255 * видтх / ширина листа)))
линия (видтх, 0, видтх, высота листа)
кц
кон
